Each dataset will have at least 2 classes, including 1 'negative' class which consists of
data that does not match any pattern.

Dataset 1: Process connects to a socket, then writes to a file.

Field count = 1
Field size = 3
Stride = 3
HASH_PROPERTIES = ['cmdline', 'name', 'ips', 'client_port', 'meta_login']
HASH_FN = hash_labels_prop
RECEPTIVE_FIELD_HASH = hash_simhash
LABELING_FN = get_ts
CLASS_COUNT = 2
DEFAULT_TENSOR_VAL = 0
CLEAN_TRAIN_DATA = False
x_train1.shape = (378, 3, 5, 1)
y_train1.shape = (378, 2)
#######################################################

Dataset 2: Process connects to a socket, then writes to a file. Process connects to a socket,

then executes a file
Field count = 1
Field size = 3
Stride = 3
HASH_PROPERTIES = ['cmdline', 'name', 'ips', 'client_port', 'meta_login']
HASH_FN = hash_labels_prop
RECEPTIVE_FIELD_HASH = hash_simhash
LABELING_FN = get_ts
CLASS_COUNT = 3
DEFAULT_TENSOR_VAL = 0
CLEAN_TRAIN_DATA = False
x_train2.shape = (6000, 3, 5, 1)
y_train2.shape = (6000, 3)
#######################################################

Dataset 3: Process connects to a socket, then writes to a file, then executes a file.

Field count = 1
Field size = 4
Stride = 4
HASH_PROPERTIES = ['cmdline', 'name', 'ips', 'client_port', 'meta_login']
HASH_FN = hash_labels_prop
RECEPTIVE_FIELD_HASH = hash_simhash
LABELING_FN = get_ts
CLASS_COUNT = 2
DEFAULT_TENSOR_VAL = 0
CLEAN_TRAIN_DATA = False
x_train3.shape = (2000, 4, 5, 1)
y_train3.shape = (2000, 2)
#######################################################

Dataset 4: Process connects to a socket, writes to a file starting with '/usr' and
reads the file named '/etc/libmap.conf'. The negative data for this dataset is exactly
the same as the pattern described above, except the file read by the process is not named
'/etc/libmap.conf'.

Field count = 1
Field size = 4
Stride = 4
HASH_PROPERTIES = ['cmdline', 'name', 'ips', 'client_port', 'meta_login']
HASH_FN = hash_labels_prop
RECEPTIVE_FIELD_HASH = hash_simhash
LABELING_FN = get_ts
CLASS_COUNT = 2
DEFAULT_TENSOR_VAL = 0
CLEAN_TRAIN_DATA = False
EMBEDDING_LENGTH = 10
EMBEDDING_DIM = 10
VOCAB_SIZE = 1000
MAX_NODES = 4
x_patchy4.shape = (2000, 4, 5, 1)
x_embed4.shape = (2000, 40)
y_train4.shape = (2000, 2)
#######################################################

Dataset 5: Process connects to a socket, writes to a file starting with '/usr' and
reads the file named '/etc/libmap.conf'. A quarter of the negative data for this dataset
is exactly the same as the pattern described above, except the file read by the process
is not named '/etc/libmap.conf'. The other quarter of the negative data is any random 4
node pattern that does not match the pattern described above, except that it has a node named
'/etc/libmap.conf' and a node starting with '/usr'.

This dataset is here to test if the model can simultaneously use
information from both the patchy-san inputs and the word embedding inputs.

Field count = 1
Field size = 4
Stride = 4
HASH_PROPERTIES = ['cmdline', 'name', 'ips', 'client_port', 'meta_login']
HASH_FN = hash_labels_prop
RECEPTIVE_FIELD_HASH = hash_simhash
LABELING_FN = get_ts
CLASS_COUNT = 2
DEFAULT_TENSOR_VAL = 0
CLEAN_TRAIN_DATA = False
EMBEDDING_LENGTH = 10
EMBEDDING_DIM = 10
VOCAB_SIZE = 1000
MAX_NODES = 4
x_patchy5.shape = (4000, 4, 5, 1)
x_embed5.shape = (4000, 40)
y_train5.shape = (4000, 2)
#######################################################

Dataset 6:
Pattern 1:Process connects to a socket, writes to a file starting with '/usr' and
reads the file named '/etc/libmap.conf'.
Pattern 2:Process connects to a socket, writes to a file starting with '/usr' and
reads the file named '/lib/libc.so.7'.
Pattern 3:Negative data that does not exactly match the patterns above.

This dataset is here to test if the model can distinguish between two patterns with
different word embeddings but same structure

Field count = 1
Field size = 4
Stride = 4
HASH_PROPERTIES = ['cmdline', 'name', 'ips', 'client_port', 'meta_login']
HASH_FN = hash_labels_prop
RECEPTIVE_FIELD_HASH = hash_simhash
LABELING_FN = get_ts
CLASS_COUNT = 3
DEFAULT_TENSOR_VAL = 0
CLEAN_TRAIN_DATA = False
EMBEDDING_LENGTH = 10
EMBEDDING_DIM = 10
VOCAB_SIZE = 1000
MAX_NODES = 4
x_patchy6.shape = (3000, 4, 5, 1)
x_embed6.shape = (3000, 40)
y_train6.shape = (3000, 2)
#######################################################

Dataset 7:
Pattern 1:Process connects to a socket, writes to a file starting with '/usr' and
reads the file named '/etc/libmap.conf'.
Pattern 2:Same as above, but the file is named '/lib/libc.so.7'.
Pattern 3:Same as above, but the file is named '/lib/libcrypto.so.8'
Pattern 4:Negative data that does not exactly match the patterns above.

This dataset is here to test if the model can distinguish between many patterns with
different word embeddings but same structure

Field count = 1
Field size = 4
Stride = 4
HASH_PROPERTIES = ['cmdline', 'name', 'ips', 'client_port', 'meta_login']
HASH_FN = hash_labels_prop
RECEPTIVE_FIELD_HASH = hash_simhash
LABELING_FN = get_ts
CLASS_COUNT = 4
DEFAULT_TENSOR_VAL = 0
CLEAN_TRAIN_DATA = False
EMBEDDING_LENGTH = 10
EMBEDDING_DIM = 10
VOCAB_SIZE = 1000
MAX_NODES = 4
x_patchy7.shape = (4000, 4, 5, 1)
x_embed7.shape = (4000, 40)
y_train7.shape = (4000, 2)
#######################################################
